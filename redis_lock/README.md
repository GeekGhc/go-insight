# redis distributed lock
redis 分布式锁

### 介绍
对于分布式场景,多个机器部署了多个服务。以插入数据为例，并发场景下，用户的插入请求可能存在并发插入
同一条数据会被重复插入，重复写入的问题会造成不可预知的风险
分布式锁机制就是为了解决这个问题，保证了多个服务之间的互斥访问资源即：一个服务抢占了分布式锁，其他服务需要等待资源锁的释放
从而保证数据的最终一致性

### 分布式锁特点
- 互斥性：同一个时刻只能有一个线程持有锁
- 可重入性：同一个服务节点获取锁之后可以再次获取资源锁
- 锁超时：防止死锁的发生，每个线程持有锁都有有超时时间，超过自动释放锁，保证其他线程能够加锁
- 对称性：对同一个锁，加锁和解锁的过程必须是同一个进程，线程支只对自己的锁负责
- 高性能和高可用：加锁和解锁高效的同时也需要保证高可用

### redis 实现
通常来讲会使用setnx+expire 命令去设置锁
但是问题是这里两个命令是分开执行的  并不具有整体的原子性  如果过程中异常 很容易造成死多的发生(无法过期)

解决方案是是结合Lua脚本实现指令的原子性

## Content

## Quick start
### Lock & Unlock
### LockRetry
### UnLockUnsafe
### UnLockSafe
### SyncDo


## Benchmarks
